"""
Curriculum Specification for Developmental DI Training

This module defines the format for curriculum that can be:
1. Hand-designed with developmental principles
2. Generated by an LLM (Gemini) with the right structure
3. Extended dynamically during training

CURRICULUM DESIGN PRINCIPLES (for LLM generation):
- Start simple, build complexity gradually
- Each pattern should build on prior understanding
- Group related patterns into developmental stages
- Include "bridge" patterns that connect concepts
- Difficulty comes from: sequence length, number dependencies, abstraction level

PATTERN SPECIFICATION FORMAT:
{
    'name': 'pattern_name',           # Unique identifier
    'description': 'Human readable',  # What this pattern teaches
    'prerequisites': ['other_pattern'], # What must be learned first
    'difficulty': 1-10,               # Relative difficulty rating
    'cognitive_load': 'low|medium|high', # Working memory demand
    'generator': callable,            # Function to generate examples
    'examples': [                     # Human-readable examples
        {'seq': [1,2,3], 'next': 4, 'explanation': 'counting up'}
    ]
}
"""

import random
from dataclasses import dataclass, field
from typing import List, Dict, Callable, Optional, Any


@dataclass
class PatternSpec:
    """Specification for a single pattern type."""
    name: str
    description: str
    difficulty: int  # 1-10
    cognitive_load: str  # 'low', 'medium', 'high'
    generator: Callable[[int, int], Dict]  # (vocab_size, seed) -> {seq, target}
    prerequisites: List[str] = field(default_factory=list)
    examples: List[Dict] = field(default_factory=list)

    def generate(self, vocab_size: int = 26, seed: int = None) -> Dict:
        """Generate a single example of this pattern."""
        if seed is not None:
            random.seed(seed)
        result = self.generator(vocab_size)
        result['pattern_type'] = self.name
        return result


@dataclass
class CurriculumStage:
    """A developmental stage containing related patterns."""
    name: str
    description: str
    patterns: List[str]  # Pattern names in this stage
    learning_goals: List[str] = field(default_factory=list)


@dataclass
class DevelopmentalCurriculum:
    """Full curriculum with stages and patterns."""
    name: str
    description: str
    stages: List[CurriculumStage]
    patterns: Dict[str, PatternSpec]

    def get_pattern(self, name: str) -> Optional[PatternSpec]:
        return self.patterns.get(name)

    def get_stage_patterns(self, stage_name: str) -> List[PatternSpec]:
        """Get all patterns in a stage."""
        for stage in self.stages:
            if stage.name == stage_name:
                return [self.patterns[p] for p in stage.patterns if p in self.patterns]
        return []

    def get_prerequisites(self, pattern_name: str) -> List[str]:
        """Get prerequisite patterns for a given pattern."""
        pattern = self.patterns.get(pattern_name)
        return pattern.prerequisites if pattern else []

    def all_pattern_names(self) -> List[str]:
        """Get all pattern names in curriculum order."""
        names = []
        for stage in self.stages:
            names.extend(stage.patterns)
        return names


# =============================================================================
# PATTERN GENERATORS
# =============================================================================

def gen_repeating(vocab_size: int) -> Dict:
    """[A, A, A, ?] → A - Simplest pattern, just repeat."""
    a = random.randint(0, vocab_size - 1)
    length = random.randint(3, 7)
    return {'sequence': [a] * length, 'target': a}


def gen_alternating(vocab_size: int) -> Dict:
    """[A, B, A, B, ?] → A - Two-element cycle."""
    a, b = random.sample(range(vocab_size), 2)
    length = random.randint(4, 8)
    seq = [a if i % 2 == 0 else b for i in range(length)]
    target = a if length % 2 == 0 else b
    return {'sequence': seq, 'target': target}


def gen_incrementing(vocab_size: int) -> Dict:
    """[1, 2, 3, ?] → 4 - Count up by 1."""
    length = random.randint(3, 6)
    start = random.randint(0, max(0, vocab_size - length - 1))
    seq = [start + i for i in range(length)]
    target = start + length
    return {'sequence': seq, 'target': target}


def gen_decrementing(vocab_size: int) -> Dict:
    """[5, 4, 3, ?] → 2 - Count down by 1."""
    length = random.randint(3, 6)
    start = random.randint(length, vocab_size - 1)
    seq = [start - i for i in range(length)]
    target = start - length
    return {'sequence': seq, 'target': target}


def gen_fixed_offset(vocab_size: int) -> Dict:
    """[2, 4, 6, ?] → 8 - Count by fixed step k."""
    length = random.randint(3, 5)
    k = random.randint(2, 4)
    start = random.randint(0, max(0, vocab_size - k * (length + 1)))
    seq = [start + i * k for i in range(length)]
    target = start + length * k
    return {'sequence': seq, 'target': target}


def gen_triple_cycle(vocab_size: int) -> Dict:
    """[A, B, C, A, B, C, ?] → A - Three-element cycle."""
    a, b, c = random.sample(range(vocab_size), 3)
    cycle = [a, b, c]
    length = random.randint(6, 9)
    seq = [cycle[i % 3] for i in range(length)]
    target = cycle[length % 3]
    return {'sequence': seq, 'target': target}


def gen_fibonacci_mod(vocab_size: int) -> Dict:
    """[1, 1, 2, 3, 5, ?] → 8 - Fibonacci sequence mod vocab."""
    length = random.randint(4, 7)
    a, b = random.randint(1, 5), random.randint(1, 5)
    seq = [a, b]
    for _ in range(length - 2):
        seq.append((seq[-1] + seq[-2]) % vocab_size)
    target = (seq[-1] + seq[-2]) % vocab_size
    return {'sequence': seq, 'target': target}


def gen_mirror(vocab_size: int) -> Dict:
    """[A, B, C, B, ?] → A - Palindrome pattern."""
    half_len = random.randint(2, 4)
    first_half = [random.randint(0, vocab_size - 1) for _ in range(half_len)]
    # Build palindrome up to middle, target is next in mirror
    seq = first_half + first_half[-2::-1][:random.randint(1, half_len-1)]
    # Target continues the palindrome
    mirror_pos = len(seq) - half_len
    target = first_half[half_len - 1 - (len(seq) - half_len)] if mirror_pos < half_len else first_half[0]
    return {'sequence': seq, 'target': target}


def gen_double(vocab_size: int) -> Dict:
    """[A, A, B, B, C, C, ?] → D, D - Repeat each element twice."""
    base_len = random.randint(2, 4)
    elements = [random.randint(0, vocab_size - 1) for _ in range(base_len)]
    seq = []
    for e in elements:
        seq.extend([e, e])
    # Remove last element, that's what we're predicting
    seq = seq[:-1]
    target = elements[-1]
    return {'sequence': seq, 'target': target}


def gen_skip_count(vocab_size: int) -> Dict:
    """[1, _, 3, _, 5, ?] → 7 - Skip counting (odd numbers)."""
    start = random.randint(0, 3)
    step = 2
    length = random.randint(3, 5)
    seq = [start + i * step for i in range(length)]
    target = start + length * step
    if target >= vocab_size:
        return gen_skip_count(vocab_size)  # Retry if out of range
    return {'sequence': seq, 'target': target}


def gen_position_based(vocab_size: int) -> Dict:
    """Value depends on position in sequence."""
    length = random.randint(4, 6)
    # Each position adds its index
    base = random.randint(0, vocab_size // 2)
    seq = [base + i for i in range(length)]
    target = base + length
    return {'sequence': seq, 'target': target}


# =============================================================================
# DEFAULT DEVELOPMENTAL CURRICULUM
# =============================================================================

def create_basic_curriculum() -> DevelopmentalCurriculum:
    """Create the basic 4-pattern curriculum (what we have now)."""
    return DevelopmentalCurriculum(
        name="Basic Pattern Completion",
        description="Foundational patterns for sequence prediction",
        stages=[
            CurriculumStage(
                name="Stage A: Memory",
                description="Patterns requiring memory of seen elements",
                patterns=["repeating", "alternating"],
                learning_goals=["Remember what was seen", "Track position in cycle"]
            ),
            CurriculumStage(
                name="Stage B: Arithmetic",
                description="Patterns requiring counting/arithmetic",
                patterns=["incrementing", "fixed_offset"],
                learning_goals=["Count up", "Generalize step size"]
            ),
        ],
        patterns={
            "repeating": PatternSpec(
                name="repeating",
                description="Repeat the same element",
                difficulty=1,
                cognitive_load="low",
                generator=gen_repeating,
                prerequisites=[],
                examples=[
                    {"seq": [3, 3, 3], "next": 3, "explanation": "Just keep repeating"}
                ]
            ),
            "alternating": PatternSpec(
                name="alternating",
                description="Alternate between two elements",
                difficulty=3,
                cognitive_load="medium",
                generator=gen_alternating,
                prerequisites=["repeating"],
                examples=[
                    {"seq": [1, 2, 1, 2], "next": 1, "explanation": "A-B-A-B cycle"}
                ]
            ),
            "incrementing": PatternSpec(
                name="incrementing",
                description="Count up by 1",
                difficulty=2,
                cognitive_load="low",
                generator=gen_incrementing,
                prerequisites=["repeating"],
                examples=[
                    {"seq": [5, 6, 7], "next": 8, "explanation": "Add 1 each time"}
                ]
            ),
            "fixed_offset": PatternSpec(
                name="fixed_offset",
                description="Count by a fixed step",
                difficulty=4,
                cognitive_load="medium",
                generator=gen_fixed_offset,
                prerequisites=["incrementing"],
                examples=[
                    {"seq": [2, 4, 6], "next": 8, "explanation": "Add 2 each time"}
                ]
            ),
        }
    )


def create_extended_curriculum() -> DevelopmentalCurriculum:
    """
    Extended curriculum with more patterns for richer learning.

    This is what Gemini could help design/expand.
    """
    return DevelopmentalCurriculum(
        name="Extended Developmental Curriculum",
        description="Comprehensive pattern curriculum with developmental staging",
        stages=[
            CurriculumStage(
                name="Stage 1: Foundation",
                description="Simplest patterns - single element focus",
                patterns=["repeating"],
                learning_goals=["Consistency", "Pattern recognition basics"]
            ),
            CurriculumStage(
                name="Stage 2: Simple Sequences",
                description="Two-element patterns and basic counting",
                patterns=["alternating", "incrementing", "decrementing"],
                learning_goals=["Position tracking", "Direction understanding"]
            ),
            CurriculumStage(
                name="Stage 3: Generalization",
                description="Parameterized patterns",
                patterns=["fixed_offset", "double", "triple_cycle"],
                learning_goals=["Abstract step size", "Longer cycles"]
            ),
            CurriculumStage(
                name="Stage 4: Complex Patterns",
                description="Patterns requiring multiple skills",
                patterns=["fibonacci_mod", "skip_count"],
                learning_goals=["Combining operations", "Modular arithmetic"]
            ),
            CurriculumStage(
                name="Stage 5: Meta-Patterns",
                description="Patterns about patterns",
                patterns=["mirror"],
                learning_goals=["Structure recognition", "Symmetry"]
            ),
        ],
        patterns={
            "repeating": PatternSpec(
                name="repeating",
                description="Repeat the same element",
                difficulty=1,
                cognitive_load="low",
                generator=gen_repeating,
                prerequisites=[],
            ),
            "alternating": PatternSpec(
                name="alternating",
                description="Alternate between two elements",
                difficulty=3,
                cognitive_load="medium",
                generator=gen_alternating,
                prerequisites=["repeating"],
            ),
            "incrementing": PatternSpec(
                name="incrementing",
                description="Count up by 1",
                difficulty=2,
                cognitive_load="low",
                generator=gen_incrementing,
                prerequisites=["repeating"],
            ),
            "decrementing": PatternSpec(
                name="decrementing",
                description="Count down by 1",
                difficulty=2,
                cognitive_load="low",
                generator=gen_decrementing,
                prerequisites=["incrementing"],
            ),
            "fixed_offset": PatternSpec(
                name="fixed_offset",
                description="Count by a fixed step k",
                difficulty=4,
                cognitive_load="medium",
                generator=gen_fixed_offset,
                prerequisites=["incrementing"],
            ),
            "double": PatternSpec(
                name="double",
                description="Each element appears twice",
                difficulty=4,
                cognitive_load="medium",
                generator=gen_double,
                prerequisites=["repeating", "alternating"],
            ),
            "triple_cycle": PatternSpec(
                name="triple_cycle",
                description="Three-element repeating cycle",
                difficulty=5,
                cognitive_load="medium",
                generator=gen_triple_cycle,
                prerequisites=["alternating"],
            ),
            "fibonacci_mod": PatternSpec(
                name="fibonacci_mod",
                description="Fibonacci sequence with modulo",
                difficulty=7,
                cognitive_load="high",
                generator=gen_fibonacci_mod,
                prerequisites=["incrementing", "fixed_offset"],
            ),
            "skip_count": PatternSpec(
                name="skip_count",
                description="Count by 2s (odd or even numbers)",
                difficulty=5,
                cognitive_load="medium",
                generator=gen_skip_count,
                prerequisites=["fixed_offset"],
            ),
            "mirror": PatternSpec(
                name="mirror",
                description="Palindrome/mirror pattern",
                difficulty=8,
                cognitive_load="high",
                generator=gen_mirror,
                prerequisites=["alternating", "double"],
            ),
        }
    )


# =============================================================================
# GEMINI CURRICULUM GENERATION PROMPT
# =============================================================================

CURRICULUM_GENERATION_PROMPT = """
You are designing a developmental curriculum for training small neural networks
on sequence pattern completion tasks.

TASK FORMAT:
- Input: A sequence of integers [a, b, c, d, ...]
- Output: Predict the next integer in the sequence
- Vocab size: 26 (integers 0-25)

CURRENT PATTERNS WE HAVE:
{current_patterns}

DESIGN PRINCIPLES:
1. Start simple, build complexity gradually
2. Each new pattern should build on previously learned skills
3. Group related patterns into developmental stages
4. Include "bridge" patterns that connect concepts
5. Consider cognitive load (working memory demands)

YOUR TASK:
Design {n_new_patterns} new patterns that:
- Fill gaps in the developmental progression
- Introduce new cognitive challenges
- Build toward more abstract reasoning

For each pattern, provide:
1. name: unique snake_case identifier
2. description: what cognitive skill it develops
3. difficulty: 1-10 scale
4. cognitive_load: low/medium/high
5. prerequisites: list of patterns that should be learned first
6. generator_logic: Python-like pseudocode for generating examples
7. examples: 3 concrete examples with explanations

Format your response as JSON:
{{
  "patterns": [
    {{
      "name": "pattern_name",
      "description": "...",
      "difficulty": 5,
      "cognitive_load": "medium",
      "prerequisites": ["pattern1", "pattern2"],
      "generator_logic": "...",
      "examples": [
        {{"seq": [1,2,3], "next": 4, "explanation": "..."}}
      ]
    }}
  ],
  "suggested_stages": [
    {{
      "name": "Stage X: Name",
      "description": "...",
      "patterns": ["pattern1", "pattern2"],
      "learning_goals": ["goal1", "goal2"]
    }}
  ]
}}
"""


def get_curriculum_prompt(curriculum: DevelopmentalCurriculum, n_new: int = 5) -> str:
    """Generate prompt for Gemini to extend the curriculum."""
    current = []
    for name, spec in curriculum.patterns.items():
        current.append(f"- {name} (difficulty={spec.difficulty}): {spec.description}")

    return CURRICULUM_GENERATION_PROMPT.format(
        current_patterns="\n".join(current),
        n_new_patterns=n_new
    )
